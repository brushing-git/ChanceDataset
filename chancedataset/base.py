from abc import ABC, abstractmethod
from . import tools
import torch

class BaseGenerator(ABC):
    """
    The base class for generating samples for the various problem types.

    attributes:
    rand_gen : numpy.random.default_rng : a random number generator with a fixed random seed

    methods:
    generate_samples : builds the samples based on the template and requirements
    boolean_samples : builds the 
    """
    def __init__(self, rng: tools.random.default_rng) -> None:
        self.rng = rng
    
    @abstractmethod
    def gen_base_sample(self):
        pass

    @abstractmethod
    def generate_samples(self):
        pass

    def boolean_samples(self, samples: list, truth_values: list, n: int) -> tuple:
        """
        Takes a list of samples and randomly produces n booleans of those samples.

        params:
        samples : list : a list of sample previously generated by the generator
        truth_values : list : a list of 1s and 0s that tracks the truth of the samples
        n : int : the number of 

        returns:
        booleans : list : a list of strings containing the boolean samples
        booleans_tv : list : a list of the truth values of the generated booleans
        """

        booleans = []
        booleans_tv = []
        sample_base = samples.copy()
        tv_base = truth_values.copy()
        
        while n > 0:
            rnd_float = self.rng.uniform()
            if rnd_float <= 0.33:
                # Negate a proposition
                indx1 = self.rng.integers(0,len(sample_base))
                prop = 'it is not the case that ' + sample_base[indx1]
                tv = int(not tv_base[indx1])
            elif rnd_float > 0.33 and rnd_float <= 0.67:
                # Conjoin two propositions
                indx1 = self.rng.integers(0,len(sample_base))
                indx2 = self.rng.integers(0,len(sample_base))
                prop = '(' + sample_base[indx1] + ' and ' + sample_base[indx2] + ')'
                tv = tv_base[indx1] and tv_base[indx2]
            else:
                # Disjoin two propositions
                indx1 = self.rng.integers(0,len(sample_base))
                indx2 = self.rng.integers(0,len(sample_base))
                prop = '(' + sample_base[indx1] + ' or ' + sample_base[indx2] + ')'
                tv = tv_base[indx1] or tv_base[indx2]
            
            # Check if the proposition is already in booleans
            if prop not in booleans:
                # Add the proposition to sample_base for reuse and to booleans
                indx = self.rng.integers(0,len(sample_base))
                sample_base.insert(indx, prop)
                tv_base.insert(indx, tv)
                booleans.append(prop)
                booleans_tv.append(tv)

                # decrement the counter
                n -= 1

        return booleans, booleans_tv
    
    def cat_xy(self, x: list, y: list) -> tools.ndarray:
        """
        Stacks two lists into a numpy array

        params:
        x : list : features
        y : list : labels

        returns:
        xy : np.ndarry : a numpy array with the labels
        """

        x = tools.asarray(x)
        y = tools.asarray(y)
        x = x.reshape(x.shape[0],1)
        y = y.reshape(y.shape[0],1)
        xy = tools.hstack((x,y))
        return xy

class BaseDataset(torch.utils.data.Dataset):
    def __init__(self, X, Y, transform, target_transform):
        self.X = X
        self.Y = Y
        self.transform = transform
        self.target_transform = target_transform

    def __len__(self):
        return len(self.Y)

    def __getitem__(self, idx):
        x = self.X[idx]
        y = self.Y[idx]
        if self.transform:
            x = self.transform(x)
        if self.target_transform:
            y = self.target_transform(y)
        return x, y